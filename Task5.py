# Задача 10

# На столе лежат n монеток. Некоторые из монеток лежат вверх решкой, а некоторые – гербом. 
# Ваша задача - определить минимальное количество монеток, которые нужно перевернуть, 
# чтобы все монетки лежали одной и той же стороной вверх.

# Входные данные:
# На вход программе подается список coins, где coins[i] равно 0, если i-я монетка лежит 
# гербом вверх, и равно 1, если i-я монетка лежит решкой вверх. Размер списка не превышает 
# 1000 элементов.

# Выходные данные:
# Программа должна вывести одно целое число - минимальное количество монеток, которые 
# нужно перевернуть.

# Пример:

# На входе: coins = [0, 1, 0, 1, 1, 0]

# На выходе: 3



# Решение 1 (через цикл for):

# coins = [0, 1, 0, 1, 1, 0]

# # Инициализируем счетчики для монеток, лежащих гербом вверх и решкой вверх
# count_heads = 0
# count_tails = 0

# # Обходим каждую монетку в списке
# for coin in coins:
#     if coin == 0:
#         count_heads += 1
#     else:
#         count_tails += 1

# # Минимальное количество переворотов будет равно меньшему из этих двух чисел
# min_flips = min(count_heads, count_tails)

# print(min_flips)



# Решение 2 (через цикл while):

# coins = [0, 1, 0, 1, 1, 0]

# # Инициализируем счетчики для монеток, лежащих гербом вверх и решкой вверх
# count_heads = 0
# count_tails = 0

# # Индекс для обхода списка
# i = 0

# # Обходим список, пока не достигнем его конца
# while i < len(coins):
#     if coins[i] == 0:
#         count_heads += 1
#     else:
#         count_tails += 1
#     i += 1

# # Минимальное количество переворотов будет равно меньшему из этих двух чисел
# min_flips = min(count_heads, count_tails)

# print(min_flips)


# Решение 3 (через встроенные функции):

coins = [0, 1, 0, 1, 1, 0]

# Подсчитываем количество монет, лежащих гербом вверх (0) и решкой вверх (1)
count_heads = coins.count(0)
count_tails = coins.count(1)

# Минимальное количество переворотов будет равно меньшему из этих двух чисел
min_flips = min(count_heads, count_tails)

print(min_flips)